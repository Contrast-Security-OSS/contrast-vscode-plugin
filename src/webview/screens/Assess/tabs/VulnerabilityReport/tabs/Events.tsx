import React, { FC, useEffect, useState } from 'react';
import {
  AssessFileVulnerability,
  AssessVulnerability,
  ReducerTypes,
  VulnerabilityEvents,
  vulnerabilityEventsTree,
} from '../../../../../../common/types';
import WarningOutlinedIcon from '@mui/icons-material/WarningOutlined';
import { useSelector } from 'react-redux';
import {
  AssessEventsHttpRequestUpdate,
  findVulnerabilityByTraceId,
} from '../../../../../utils/helper';
import { renderContent } from '../../../../../utils/formattedText';

interface PaneHeaderType {
  node: vulnerabilityEventsTree;
  onClick: () => void;
  show: boolean;
}
type WithPadding<T> = T & { p: number };

const handleTypeIcon = (type: string) => {
  if (
    [
      'A2O',
      'A2P',
      'A2A',
      'A2R',
      'O2A',
      'O2O',
      'O2P',
      'O2R',
      'P2A',
      'P2O',
      'P2P',
      'P2R',
    ].includes(type)
  ) {
    return ' #BABABA';
  }

  switch (type) {
    case 'Creation':
      return '#F78A31';
    case 'Trigger':
      return '#E63025';
    case 'Tag':
      return '#AECD43';
    default:
      return 'none';
  }
};
export const PaneHeader: FC<PaneHeaderType> = ({ node, onClick, show }) => {
  const { child, label, type } = node;
  const arrowClass = show ? 'fa fa-angle-down' : 'fa fa-angle-right';
  return (
    <div className="pane-header" role="pane">
      {child !== undefined && child !== null && child?.length > 0 && (
        <i
          className={arrowClass}
          style={{ fontSize: '20px' }}
          aria-hidden="true"
          onClick={onClick}
        ></i>
      )}
      {type !== undefined && type !== null && (
        <WarningOutlinedIcon
          data-testid="warning-icon"
          fontSize="small"
          style={{ color: handleTypeIcon(type as string) }}
        />
      )}

      <div
        dangerouslySetInnerHTML={{
          __html: renderContent(label ?? ''),
        }}
      />
    </div>
  );
};

const PanelBody: FC<WithPadding<{ child: vulnerabilityEventsTree[] }>> = ({
  child,
  p,
}) => (child?.length > 0 ? <TreeView tree={child} p={p + 10} /> : null);

export const TreeRow: FC<{ node: vulnerabilityEventsTree; p: number }> = ({
  node,
  p,
}) => {
  const [show, setShow] = useState(false);
  useEffect(() => {
    if (node !== undefined && node.isRoot !== undefined && node.isRoot) {
      setShow(true);
    }
  }, [node]);
  return (
    <div style={{ marginLeft: `${p}px` }} className="head">
      <PaneHeader node={node} onClick={() => setShow(!show)} show={show} />
      {show && <PanelBody child={node.child || []} p={p} />}
    </div>
  );
};

export const TreeView: FC<WithPadding<{ tree: vulnerabilityEventsTree[] }>> = ({
  tree,
  p = 0,
}) => tree?.map((node, index) => <TreeRow key={index} node={node} p={p} />);

const Events = ({ vulnerability }: { vulnerability: unknown }) => {
  const vulnerabilitiesList = useSelector(
    (state: ReducerTypes) => state.assessFilter.allFiles
  );
  const scaAutoRefresh = useSelector(
    (state: ReducerTypes) => state.assessFilter.scaAutoRefresh
  );
  const [eventTree, setEventTree] = useState<vulnerabilityEventsTree[]>([]);
  const [isEventsthere, setEventsIsTere] = useState(false);
  const [traceId, setTraceId] = useState<null | string>(null);
  useEffect(() => {
    if (vulnerability !== null && vulnerability !== undefined) {
      const activeVul = vulnerability as AssessVulnerability;
      setTraceId(activeVul.traceId ?? null);
      const { data } = activeVul.events as VulnerabilityEvents;
      if (
        data[0].child !== undefined &&
        data[0].child !== null &&
        data[0].child?.length > 0
      ) {
        setEventsIsTere(true);
        const alterData = Array.isArray(data) ? data : [data];
        setEventTree(alterData);
      }
    }
  }, [vulnerability]);

  useEffect(() => {
    if (
      vulnerabilitiesList !== undefined &&
      vulnerabilitiesList !== null &&
      vulnerabilitiesList.responseData !== null &&
      vulnerabilitiesList.responseData !== undefined
    ) {
      const vul =
        vulnerabilitiesList.responseData as unknown as AssessFileVulnerability &
          AssessVulnerability;
      if (isEventsthere === false && traceId !== null) {
        const b = findVulnerabilityByTraceId([vul], traceId);
        if (b !== null && b !== undefined) {
          if (
            b?.events &&
            b?.events?.data !== undefined &&
            b?.events?.data.length > 0 &&
            b?.events?.data[0]?.child &&
            b?.events?.data[0]?.child?.length > 0
          ) {
            setEventTree(b.events?.data);
          } else {
            setEventTree([]);
          }
        }
      }
    }
  }, [vulnerabilitiesList, isEventsthere, traceId]);

  useEffect(() => {
    if (
      !isEventsthere &&
      vulnerability !== null &&
      vulnerability !== undefined &&
      scaAutoRefresh !== null
    ) {
      const node = vulnerability as unknown as AssessVulnerability;
      AssessEventsHttpRequestUpdate(node);
    }
  }, [isEventsthere, scaAutoRefresh]);

  return (
    <div className="events">
      <TreeView tree={eventTree} p={10} />
    </div>
  );
};

export { Events };
