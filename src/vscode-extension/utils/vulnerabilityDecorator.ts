/* eslint-disable @typescript-eslint/no-explicit-any */
import {
  MarkdownString,
  Position,
  Range,
  TextEditorDecorationType,
  window,
  workspace,
  TextEditorRevealType,
} from 'vscode';
import * as vscode from 'vscode';
import {
  CustomFileVulnerability,
  PopupMessage,
  Vulnerability,
} from '../../common/types';
import { slotInstance } from './helper';
import { localeI18ln } from '../../l10n';
import {
  closeStatusBarItem,
  initializeStatusBarItem,
  updateStatusBarItem,
} from './statusBarSeverity';
import { getScanResultById } from '../api/services/apiService';

interface VulFile {
  lineNumber: number;
  popupMessage: PopupMessage;
  severity: string;
  risk?: string;
  id: string;
  label?: string;
}

interface FileReport {
  filePath: string;
  vulReport: VulFile[];
  childDetails: { severity: string }[];
  fileName: string;
  risk?: string;
}

// --------------- Global variables -----------------------
let decorationType: TextEditorDecorationType | null = null;
let vulReport: VulFile[] = [];

const serverityBall = (severity: string) => {
  switch (severity) {
    case 'CRITICAL':
      return 'ðŸ”´';
    case 'HIGH':
      return 'ðŸŸ ';
    case 'MEDIUM':
      return 'ðŸŸ¡';
    case 'LOW':
      return 'âšª';
    default:
      return 'ðŸ”´';
      break;
  }
};
class HoverProvider implements vscode.HoverProvider {
  public async provideHover(
    document: vscode.TextDocument,
    position: vscode.Position
  ): Promise<vscode.Hover | undefined> {
    const lineNumber = position.line + 1;
    const matchingVul = vulReport.find((val) => val.lineNumber === lineNumber);
    if (matchingVul) {
      const { popupMessage, severity, id, label } = matchingVul;
      const hoverMessage = new MarkdownString();
      hoverMessage.appendMarkdown(
        `#### ${serverityBall(severity)} [${severity}] ${(label ?? '') || 'No message'}\n`
      );
      hoverMessage.appendMarkdown(`\n---\n`);
      const res = await getScanResultById(id);
      if (res.responseData !== null && res.responseData !== undefined) {
        if (typeof res.responseData === 'string') {
          hoverMessage.appendMarkdown(
            `Advice: ${processParagraphSyntax(res.responseData)}\n`
          );
        } else {
          hoverMessage.appendMarkdown(`Advice: No advice available\n`);
        }
      }
      hoverMessage.appendMarkdown(`\n---\n`);
      hoverMessage.appendMarkdown(
        `\n**Last Detected Date**: ${formatDate(popupMessage?.lastDetected_date as string)} &nbsp; &nbsp; | &nbsp; &nbsp; **Status**: ${popupMessage.status}  &nbsp; &nbsp; | &nbsp; &nbsp; [More options...](${popupMessage.link})`
      );
      hoverMessage.isTrusted = true;

      return new vscode.Hover(hoverMessage);
    }
    return undefined;
  }
}

function registerHoverProvider() {
  vscode.languages.registerHoverProvider(
    { scheme: 'file', language: '*' },
    new HoverProvider()
  );
}

registerHoverProvider();

async function openVulFile(payload: CustomFileVulnerability) {
  const {
    filePath,
    fileName,
    popupMessage = { message: '' },
    lineNumber = 0,
    severity = 'LOW',
    level,
    child = [],
    scrollToLine = false,
    id = '',
    label = '',
  } = payload;

  vulReport = [];

  if (level === 1 && child?.length > 0) {
    child.forEach((vul: Vulnerability) => {
      vulReport.push({
        popupMessage: vul.popupMessage,
        lineNumber: vul.lineNumber,
        severity: vul.severity,
        id: vul.id ?? '',
        label: vul.label,
      });
    });
  } else {
    vulReport.push({
      popupMessage,
      lineNumber,
      severity,
      id,
      label,
    });
  }

  const priorityMap: Record<string, number> = {
    CRITICAL: 4,
    HIGH: 3,
    MEDIUM: 2,
    LOW: 1,
  };

  vulReport = vulReport.reduce(
    (acc, current) => {
      const existing = acc.find((vul) => vul.lineNumber === current.lineNumber);
      if (
        !existing ||
        priorityMap[current.severity] > priorityMap[existing.severity]
      ) {
        return acc
          .filter((vul) => vul.lineNumber !== current.lineNumber)
          .concat(current);
      } else if (
        priorityMap[current.severity] === priorityMap[existing.severity]
      ) {
        return acc;
      }
      return acc;
    },
    [] as typeof vulReport
  );

  const risks = vulReport.map((vul) => {
    return { id: vul.id, risk: '' };
  });

  vulReport = vulReport.map((vul) => {
    const risk = risks.find((r) => r.id === vul.id)?.risk !== null || 'Unknown';
    return { ...vul, risk };
  }) as VulFile[];

  await decorateTextEditor(
    {
      filePath: filePath ?? '',
      vulReport,
      childDetails: child,
      fileName: fileName ?? '',
    },
    scrollToLine
  );
}
const processParagraphSyntax = (text: string): string => {
  if (text) {
    text = text.replace(/{{#paragraph}}/g, '').replace(/{{\/paragraph}}/g, ' ');
    text = text.replace(/\\n/g, ' ').replace(/"/g, '');
    return text.trim();
  }
  return 'No Advise found';
};

const formatDate = (isoDate: string): string => {
  const date = new Date(isoDate);
  const options: Intl.DateTimeFormatOptions = {
    day: '2-digit',
    month: 'long',
    year: 'numeric',
  };
  return date.toLocaleDateString('en-GB', options);
};

const decoratorAction = async (
  file: vscode.Uri,
  annotationList: VulFile[],
  scrollToLine: boolean
) => {
  const ActiveTextDocument = await window.showTextDocument(
    await workspace.openTextDocument(file)
  );

  if (decorationType) {
    ActiveTextDocument.setDecorations(decorationType, []);
    decorationType.dispose();
  }

  decorationType = window.createTextEditorDecorationType({
    textDecoration: 'underline red wavy',
    overviewRulerColor: 'rgba(255,0,0,0.8)',
  });

  let listOfAnnotated: any[] = [];
  if (
    annotationList.length === 1 &&
    annotationList[0].id === '' &&
    annotationList[0].label === ''
  ) {
    listOfAnnotated = [];
  } else {
    listOfAnnotated = annotationList
      .filter((val: { lineNumber: number }) => {
        return val.lineNumber <= ActiveTextDocument.document.lineCount;
      })
      .map((vul: VulFile) => {
        const { lineNumber } = vul;
        const lineText = ActiveTextDocument.document.lineAt(
            lineNumber - 1
          ).text,
          firstNonWhitespaceIndex = lineText.search(/\S|$/),
          lastNonWhitespaceIndex = lineText.trimEnd().length,
          startPos = new Position(lineNumber - 1, firstNonWhitespaceIndex),
          endPos = new Position(lineNumber - 1, lastNonWhitespaceIndex);

        return {
          range: new Range(startPos, endPos),
        };
      });
  }

  ActiveTextDocument.setDecorations(decorationType!, listOfAnnotated);
  if (listOfAnnotated.length === 1) {
    const { range } = listOfAnnotated[0];

    if (scrollToLine === true) {
      ActiveTextDocument.revealRange(range, TextEditorRevealType.InCenter);
    }
  }
  slotInstance.setSlot(true);
};

async function decorateTextEditor(
  fileReport: FileReport,
  scrollToLine: Boolean
) {
  const { filePath, vulReport, childDetails, fileName } = fileReport;
  let high = 0,
    medium = 0,
    low = 0,
    critical = 0;

  // Compute severity counts
  childDetails.forEach((vul: { severity: string }) => {
    switch (vul.severity) {
      case 'CRITICAL':
        critical++;
        break;
      case 'HIGH':
        high++;
        break;
      case 'MEDIUM':
        medium++;
        break;
      case 'LOW':
        low++;
        break;
    }
  });

  // Find the file and open it in VS Code
  const openFileDocument = await workspace.findFiles(`${filePath}`);

  if (openFileDocument.length === 0) {
    console.error('File not found:', filePath);
    return; // Exit if the file isn't found
  }

  if (openFileDocument.length > 0) {
    await decoratorAction(
      openFileDocument[0],
      vulReport,
      scrollToLine as boolean
    );
  } else {
    window.showErrorMessage(
      `${fileName} ${localeI18ln.getTranslation('apiResponse.fileNotFound')} ðŸ˜”`
    );
  }

  initializeStatusBarItem();
  updateStatusBarItem(critical, high, medium, low);

  window.onDidChangeActiveTextEditor(() => {
    const visible = window.visibleTextEditors;
    if (visible.length === 0) {
      closeStatusBarItem();
    } else {
      updateStatusBarItem(critical, high, medium, low);
    }
  });
}

export { openVulFile };
