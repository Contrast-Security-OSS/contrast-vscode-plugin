/* eslint-disable @typescript-eslint/no-explicit-any */
import {
  MarkdownString,
  Position,
  Range,
  TextEditorDecorationType,
  window,
  workspace,
  TextEditorRevealType,
} from 'vscode';
import * as vscode from 'vscode';
import {
  CustomFileVulnerability,
  PopupMessage,
  Vulnerability,
  VulnerabilityOverview,
} from '../../common/types';
import { getHighlightPath } from './helper';
import { localeI18ln } from '../../l10n';
import {
  closeStatusBarItem,
  initializeStatusBarItem,
  updateStatusBarItem,
} from './statusBarSeverity';
import { getScanResultById } from '../api/services/apiService';

interface VulFile {
  lineNumber: number;
  popupMessage: PopupMessage;
  severity: string;
  risk?: string;
  id: string;
  label?: string;
  overview?: VulnerabilityOverview;
}

interface FileReport {
  filePath: string;
  vulReport: VulFile[];
  childDetails: { severity: string }[];
  fileName: string;
  risk?: string;
  label?: string;
}
type SourceType = 'scan' | 'assess';

// --------------- Global variables -----------------------
let decorationType: TextEditorDecorationType | null = null;
let vulReport: VulFile[] = [];
let source: SourceType = 'assess';

const serverityBall = (severity: string) => {
  switch (severity.toUpperCase()) {
    case 'CRITICAL':
      return 'ðŸ”´';
    case 'HIGH':
      return 'ðŸŸ ';
    case 'MEDIUM':
      return 'ðŸŸ¡';
    case 'LOW':
      return 'âš«';
    case 'NOTE':
      return 'âšª';
    default:
      return 'ðŸ”´';
  }
};

function removeMustacheTagsOnly(text: string) {
  return text.replace(/{{[#\/]?[^}]+}}/g, '').trim();
}
class HoverProvider implements vscode.HoverProvider {
  public async provideHover(
    document: vscode.TextDocument,
    position: vscode.Position
  ): Promise<vscode.Hover | undefined> {
    const lineNumber = position.line + 1;
    const matchingVul = vulReport.find((val) => +val.lineNumber === lineNumber);
    if (matchingVul) {
      const { popupMessage, severity, id, label, risk } = matchingVul;
      const hoverMessage = new MarkdownString();
      const appendAdvice = (text: string) => {
        const adviceText =
          text !== null ? removeMustacheTagsOnly(text) : 'No advice available';
        hoverMessage.appendMarkdown(`**Advice:** ${adviceText}\n`);
        hoverMessage.appendMarkdown(`\n---\n`);
      };
      const appendLastDetectedInfo = (date?: string) => {
        hoverMessage.appendMarkdown(
          `\n**Last Detected Date**: ${date ?? 'N/A'} &nbsp; &nbsp; | &nbsp; &nbsp; **Status**: ${popupMessage.status}  &nbsp; &nbsp; | &nbsp; &nbsp; [More options...](${popupMessage.link})`
        );
      };

      hoverMessage.appendMarkdown(
        `#### ${serverityBall(severity)} [${severity}] ${(label ?? '') || 'No message'}\n`
      );
      hoverMessage.appendMarkdown(`\n---\n`);
      if (source === 'scan') {
        const res = await getScanResultById(id);
        if (res.responseData !== null && res.responseData !== undefined) {
          typeof res.responseData === 'string'
            ? appendAdvice(processParagraphSyntax(res.responseData))
            : appendAdvice(processParagraphSyntax('No advice available'));
        }
        appendLastDetectedInfo(
          formatDate(popupMessage?.lastDetected_date as string)
        );
      } else if (source === 'assess') {
        appendAdvice(risk ?? 'No advice available');
        appendLastDetectedInfo(popupMessage?.lastDetected_date);
      }
      hoverMessage.isTrusted = true;

      return new vscode.Hover(hoverMessage);
    }
    return undefined;
  }
}

function registerHoverProvider() {
  vscode.languages.registerHoverProvider(
    { scheme: 'file', language: '*' },
    new HoverProvider()
  );
}

registerHoverProvider();

async function openVulFile(payload: CustomFileVulnerability, type: SourceType) {
  source = type;
  const {
    filePath,
    fileName,
    popupMessage = { message: '' },
    lineNumber = 0,
    severity = 'LOW',
    level,
    child = [],
    scrollToLine = false,
    id = '',
    label = '',
    overview,
  } = payload;

  vulReport = [];

  if (level === 1 && child?.length > 0) {
    child.forEach((vul: Vulnerability) => {
      vulReport.push({
        popupMessage: vul.popupMessage,
        lineNumber: vul.lineNumber,
        severity: vul.severity,
        id: vul.id ?? '',
        label: vul.label,
        risk: type === 'assess' ? (vul.overview?.risk?.text ?? '') : '',
      });
    });
  } else {
    vulReport.push({
      popupMessage,
      lineNumber,
      severity,
      id,
      label,
      risk: type === 'assess' ? (overview?.risk?.text ?? '') : '',
    });
  }

  const priorityMap: Record<string, number> = {
    CRITICAL: 4,
    HIGH: 3,
    MEDIUM: 2,
    LOW: 1,
  };

  vulReport = vulReport.reduce(
    (acc, current) => {
      const existing = acc.find((vul) => vul.lineNumber === current.lineNumber);
      if (
        !existing ||
        priorityMap[current.severity] > priorityMap[existing.severity]
      ) {
        return acc
          .filter((vul) => vul.lineNumber !== current.lineNumber)
          .concat(current);
      } else if (
        priorityMap[current.severity] === priorityMap[existing.severity]
      ) {
        return acc;
      }
      return acc;
    },
    [] as typeof vulReport
  );

  await decorateTextEditor(
    {
      filePath: filePath ?? '',
      vulReport,
      childDetails: child,
      fileName: fileName ?? '',
      label,
    },
    scrollToLine
  );
}
const processParagraphSyntax = (text: string): string => {
  if (text) {
    text = text.replace(/{{#paragraph}}/g, '').replace(/{{\/paragraph}}/g, ' ');
    text = text.replace(/\\n/g, ' ').replace(/"/g, '');
    return text.trim();
  }
  return 'No Advise found';
};

const formatDate = (isoDate: string): string => {
  const date = new Date(isoDate);
  const options: Intl.DateTimeFormatOptions = {
    day: '2-digit',
    month: 'long',
    year: 'numeric',
  };
  return date.toLocaleDateString('en-GB', options);
};

const decoratorAction = async (
  file: vscode.Uri,
  annotationList: VulFile[],
  scrollToLine: boolean
) => {
  const ActiveTextDocument = await window.showTextDocument(
    await workspace.openTextDocument(file)
  );

  if (decorationType) {
    ActiveTextDocument.setDecorations(decorationType, []);
    decorationType.dispose();
  }

  decorationType = window.createTextEditorDecorationType({
    textDecoration: 'underline red wavy',
    overviewRulerColor: 'rgba(255,0,0,0.8)',
  });

  let listOfAnnotated: any[] = [];
  if (
    annotationList.length === 1 &&
    annotationList[0].id === '' &&
    annotationList[0].label === ''
  ) {
    listOfAnnotated = [];
  } else {
    listOfAnnotated = annotationList
      .filter((val: { lineNumber: number }) => {
        return val.lineNumber <= ActiveTextDocument.document.lineCount;
      })
      .map((vul: VulFile) => {
        const { lineNumber } = vul;
        const lineText = ActiveTextDocument.document.lineAt(
            lineNumber - 1
          ).text,
          firstNonWhitespaceIndex = lineText.search(/\S|$/),
          lastNonWhitespaceIndex = lineText.trimEnd().length,
          startPos = new Position(lineNumber - 1, firstNonWhitespaceIndex),
          endPos = new Position(lineNumber - 1, lastNonWhitespaceIndex);

        return {
          range: new Range(startPos, endPos),
        };
      });
  }

  ActiveTextDocument.setDecorations(decorationType!, listOfAnnotated);
  if (listOfAnnotated.length === 1) {
    const { range } = listOfAnnotated[0];

    if (scrollToLine === true) {
      ActiveTextDocument.revealRange(range, TextEditorRevealType.InCenter);
    }
  }
};

async function decorateTextEditor(
  fileReport: FileReport,
  scrollToLine: Boolean
) {
  const { filePath, vulReport, childDetails, fileName, label } = fileReport;
  let high = 0,
    medium = 0,
    low = 0,
    critical = 0,
    note = 0;

  // Compute severity counts
  childDetails.forEach((vul: { severity: string }) => {
    switch (vul.severity.toUpperCase()) {
      case 'CRITICAL':
        critical++;
        break;
      case 'HIGH':
        high++;
        break;
      case 'MEDIUM':
        medium++;
        break;
      case 'LOW':
        low++;
        break;
      case 'NOTE':
        note++;
        break;
    }
  });

  const path = await getHighlightPath(filePath);
  if (path === '') {
    return;
  }

  const openFileDocument = await workspace.findFiles(path);

  if (openFileDocument.length === 0) {
    if (source === 'scan') {
      vscode.window.showWarningMessage(
        `${localeI18ln.getTranslation('persistResponse.wrongRelativePath')}: \nâ†’ ${label ?? filePath}`
      );
    }

    console.error('File not found:', filePath);
    return; // Exit if the file isn't found
  }

  if (openFileDocument.length > 0) {
    await decoratorAction(
      openFileDocument[0],
      vulReport,
      scrollToLine as boolean
    );
  } else {
    window.showErrorMessage(
      `${fileName} ${localeI18ln.getTranslation('apiResponse.fileNotFound')} ðŸ˜”`
    );
  }

  initializeStatusBarItem();
  updateStatusBarItem(critical, high, medium, low, note);

  window.onDidChangeActiveTextEditor(() => {
    const visible = window.visibleTextEditors;
    if (visible.length === 0) {
      closeStatusBarItem();
    } else {
      updateStatusBarItem(critical, high, medium, low, note);
    }
  });
}

export { openVulFile, decoratorAction };
