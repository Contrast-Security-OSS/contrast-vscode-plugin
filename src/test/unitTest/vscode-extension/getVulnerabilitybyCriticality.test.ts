import { getDataFromCache } from '../../../vscode-extension/cache/cacheManager';
import { resolveFailure } from '../../../vscode-extension/utils/errorHandling';
import { ApiResponse } from '../../../common/types';
import { l10n } from '../../../l10n';
import { getVulnerabilitybyCriticality } from '../../../vscode-extension/api/services/apiService';
import path from 'path';
import { Uri } from 'vscode';

jest.mock('../../../vscode-extension/utils/errorHandling');
jest.mock('../../../vscode-extension/cache/cacheManager');

jest.mock('vscode', () => {
  const UIKind = { Desktop: 1, Web: 2 };
  return {
    UIKind,
    env: {
      language: 'en',
      appName: 'VSCode',
      uiKind: UIKind.Desktop,
    },
    workspace: {
      workspaceFolders: [{ uri: { fsPath: '/path/to/mock/workspace' } }],
      onDidChangeConfiguration: jest.fn(),
    },
    window: {
      createTreeView: jest.fn().mockReturnValue({
        onDidChangeVisibility: jest.fn(),
      }),
      activeTextEditor: {
        document: {
          fileName: 'test.js',
        },
      },
    },
    TreeItem: class {
      [x: string]: { dark: Uri; light: Uri };
      constructor(
        label: { dark: Uri; light: Uri },
        /* eslint-disable @typescript-eslint/no-explicit-any */
        command: any = null,
        /* eslint-disable @typescript-eslint/no-explicit-any */
        icon: any = null
      ) {
        this.label = label;
        if (command !== null) {
          this.command = {
            title: label,
            command: command,
          } as any;
        }
        if (icon !== null) {
          const projectRoot = path.resolve(__dirname, '..');
          const iconPath = Uri.file(path.join(projectRoot, 'assets', icon));
          this.iconPath = {
            dark: iconPath,
            light: iconPath,
          };
        }
      }
    },
    Uri: {
      file: jest.fn().mockReturnValue('mockUri'),
    },
    commands: {
      registerCommand: jest.fn(),
    },
    languages: {
      registerHoverProvider: jest.fn(),
    },
  };
});

jest.mock(
  '../../../vscode-extension/commands/ui-commands/webviewHandler',
  () => ({
    ContrastPanelInstance: {
      postMessage: jest.fn(),
    },
  })
);

const locale = new l10n('en');

const mockedResolveFailure = resolveFailure as jest.MockedFunction<
  typeof resolveFailure
>;
const mockedGetDataFromCache = getDataFromCache as jest.MockedFunction<
  typeof getDataFromCache
>;

describe('getVulnerabilitybyCriticality', () => {
  beforeEach(() => {
    mockedResolveFailure.mockReset();
    mockedGetDataFromCache.mockReset();
  });

  it('should return filtered vulnerabilities by severity when data is available', async () => {
    const severity = 'high';

    const mockFileData = {
      label: 'testFile.js',
      child: [
        {
          label: 'subFile1.js',
          child: [
            { severity: 'high', id: 1 },
            { severity: 'low', id: 2 },
          ],
        },
        { label: 'subFile2.js', child: [{ severity: 'high', id: 3 }] },
      ],
    };

    mockedGetDataFromCache.mockResolvedValue({
      responseData: {
        child: [mockFileData],
      },
    } as unknown as ApiResponse);

    const response = await getVulnerabilitybyCriticality(severity);

    expect(mockedGetDataFromCache).toHaveBeenCalled();
    expect(response).toEqual({
      responseData: {
        child: [
          {
            child: [
              {
                child: [
                  {
                    id: 1,
                    severity: 'high',
                  },
                  {
                    id: 2,
                    severity: 'low',
                  },
                ],
                label: 'subFile1.js',
              },
              {
                child: [
                  {
                    id: 3,
                    severity: 'high',
                  },
                ],
                label: 'subFile2.js',
              },
            ],
            label: 'testFile.js',
          },
        ],
      },
    });
  });

  it('should return empty response if no vulnerabilities match the severity', async () => {
    const severity = 'critical';

    const mockFileData = {
      label: 'testFile.js',
      child: [
        { label: 'subFile1.js', child: [{ severity: 'low', id: 1 }] },
        { label: 'subFile2.js', child: [{ severity: 'medium', id: 2 }] },
      ],
    };

    mockedGetDataFromCache.mockResolvedValue({
      responseData: {
        child: [mockFileData],
      },
    } as unknown as ApiResponse);

    const response = await getVulnerabilitybyCriticality(severity);

    expect(mockedGetDataFromCache).toHaveBeenCalled();
    expect(response).toEqual({
      responseData: {
        child: [
          {
            child: [
              {
                child: [
                  {
                    id: 1,
                    severity: 'low',
                  },
                ],
                label: 'subFile1.js',
              },
              {
                child: [
                  {
                    id: 2,
                    severity: 'medium',
                  },
                ],
                label: 'subFile2.js',
              },
            ],
            label: 'testFile.js',
          },
        ],
      },
    });
  });

  it('should return failure if no file data is found in the cache', async () => {
    const severity = 'high';

    mockedGetDataFromCache.mockResolvedValue({
      responseData: {
        child: [],
      },
    } as unknown as ApiResponse);

    mockedResolveFailure.mockReturnValue({
      message: locale.getTranslation('apiResponse.fileNotFound') as string,
      code: 400,
      status: 'failure',
      responseData: {},
    });

    const response = await getVulnerabilitybyCriticality(severity);

    expect(mockedResolveFailure).toHaveBeenCalledTimes(0);
    expect(response).toEqual({
      responseData: {
        child: [],
      },
    });
  });
});
