import { getDataOnlyFromCacheAssess } from '../../../vscode-extension/cache/cacheManager';
import { localeI18ln } from '../../../l10n';
import {
  resolveFailure,
  resolveSuccess,
} from '../../../vscode-extension/utils/errorHandling';
import { getVulnerabilityByTraceId } from '../../../vscode-extension/api/services/apiService';
import path from 'path';
import { Uri } from 'vscode';

jest.mock('../../../vscode-extension/cache/cacheManager', () => ({
  getDataOnlyFromCacheAssess: jest.fn(),
}));

jest.mock('../../../l10n', () => ({
  localeI18ln: {
    getTranslation: jest.fn(),
  },
}));

jest.mock('../../../vscode-extension/utils/errorHandling', () => ({
  resolveFailure: jest.fn(),
  resolveSuccess: jest.fn(),
}));

/* eslint-disable @typescript-eslint/no-explicit-any */
jest.mock('vscode', () => ({
  env: {
    language: 'en',
    appName: 'VSCode',
  },
  workspace: {
    workspaceFolders: [{ uri: { fsPath: '/path/to/mock/workspace' } }],
    onDidChangeConfiguration: jest.fn(),
  },
  window: {
    activeTextEditor: null,
  },

  TreeItem: class {
    [x: string]: { dark: Uri; light: Uri };
    constructor(
      label: { dark: Uri; light: Uri },
      command: any = null,
      icon: any = null
    ) {
      this.label = label;
      if (command !== null) {
        this.command = {
          title: label,
          command: command,
        } as any;
      }
      if (icon !== null) {
        const projectRoot = path.resolve(__dirname, '..');
        const iconPath = Uri.file(path.join(projectRoot, 'assets', icon));
        this.iconPath = {
          dark: iconPath,
          light: iconPath,
        };
      }
    }
  },
  Uri: {
    file: jest.fn().mockReturnValue('mockUri'),
  },
  commands: {
    registerCommand: jest.fn(),
  },
  languages: {
    registerHoverProvider: jest.fn(),
  },
}));

jest.mock(
  '../../../vscode-extension/commands/ui-commands/webviewHandler',
  () => ({
    ContrastPanelInstance: {
      postMessage: jest.fn(),
    },
  })
);

const mockVulnerabilityData = {
  responseData: {
    child: [
      {
        label: 'file1.js',
        child: [
          {
            traceId: 'trace123',
            vulnerabilityDetails: 'vulnerability 1 details',
          },
          {
            traceId: 'trace456',
            vulnerabilityDetails: 'vulnerability 2 details',
          },
        ],
      },
      {
        label: 'file2.js',
        child: [
          {
            traceId: 'trace789',
            vulnerabilityDetails: 'vulnerability 3 details',
          },
        ],
      },
    ],
  },
};

describe('getVulnerabilityByTraceId', () => {
  const traceId = 'trace123';

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should return the vulnerability details when traceId is found', async () => {
    (getDataOnlyFromCacheAssess as jest.Mock).mockResolvedValue(
      mockVulnerabilityData
    );
    (localeI18ln.getTranslation as jest.Mock).mockReturnValue(
      'Vulnerability fetched successfully'
    );
    (resolveSuccess as jest.Mock).mockReturnValue({
      message: 'Success',
      statusCode: 200,
      data: mockVulnerabilityData.responseData.child[0].child[0],
    });

    const result = await getVulnerabilityByTraceId(traceId);

    expect(getDataOnlyFromCacheAssess).toHaveBeenCalled();
    expect(resolveSuccess).toHaveBeenCalledWith(
      'Vulnerability fetched successfully',
      200,
      mockVulnerabilityData.responseData.child[0].child[0]
    );
    expect(result).toEqual({
      message: 'Success',
      statusCode: 200,
      data: mockVulnerabilityData.responseData.child[0].child[0],
    });
  });

  it('should return undefined if the traceId is not found', async () => {
    (getDataOnlyFromCacheAssess as jest.Mock).mockResolvedValue(
      mockVulnerabilityData
    );
    (localeI18ln.getTranslation as jest.Mock).mockReturnValue(
      'TraceId not found'
    );
    (resolveFailure as jest.Mock).mockReturnValue({
      message: 'TraceId not found',
      statusCode: 400,
    });

    const result = await getVulnerabilityByTraceId('trace999');

    expect(getDataOnlyFromCacheAssess).toHaveBeenCalled();
    expect(result).toBeUndefined();
    expect(resolveFailure).not.toHaveBeenCalled();
  });
});
